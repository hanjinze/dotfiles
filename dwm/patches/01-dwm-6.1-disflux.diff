--- dwm.c	2013-03-22 08:49:32.415941962 -0500
+++ dwm.c.disflux	2013-03-22 08:49:20.684941592 -0500
@@ -131,6 +131,7 @@
 	int nmaster;
 	int num;
 	int by;               /* bar geometry */
+	int bby;	      /* bottom bar geometry */
 	int mx, my, mw, mh;   /* screen size */
 	int wx, wy, ww, wh;   /* window area  */
 	unsigned int seltags;
@@ -138,11 +139,14 @@
 	unsigned int tagset[2];
 	Bool showbar;
 	Bool topbar;
+	Bool showbottombar;
+	Bool bottombar;
 	Client *clients;
 	Client *sel;
 	Client *stack;
 	Monitor *next;
 	Window barwin;
+	Window bbarwin;
 	const Layout *lt[2];
 };
 
@@ -192,6 +196,7 @@
 static Bool gettextprop(Window w, Atom atom, char *text, unsigned int size);
 static void grabbuttons(Client *c, Bool focused);
 static void grabkeys(void);
+static void grid(Monitor *m);
 static void incnmaster(const Arg *arg);
 static void initfont(const char *fontstr);
 static void keypress(XEvent *e);
@@ -229,6 +234,7 @@
 static int textnw(const char *text, unsigned int len);
 static void tile(Monitor *);
 static void togglebar(const Arg *arg);
+static void togglebottombar(const Arg *arg);
 static void togglefloating(const Arg *arg);
 static void toggletag(const Arg *arg);
 static void toggleview(const Arg *arg);
@@ -256,6 +262,7 @@
 /* variables */
 static const char broken[] = "broken";
 static char stext[256];
+static char btext[256];
 static int screen;
 static int sw, sh;           /* X display screen geometry width, height */
 static int bh, blw = 0;      /* bar geometry */
@@ -515,6 +522,8 @@
 	}
 	XUnmapWindow(dpy, mon->barwin);
 	XDestroyWindow(dpy, mon->barwin);
+	XUnmapWindow(dpy, mon->bbarwin);
+	XDestroyWindow(dpy, mon->bbarwin);
 	free(mon);
 }
 
@@ -585,8 +594,10 @@
 				XFreePixmap(dpy, dc.drawable);
 			dc.drawable = XCreatePixmap(dpy, root, sw, bh, DefaultDepth(dpy, screen));
 			updatebars();
-			for(m = mons; m; m = m->next)
+			for(m = mons; m; m = m->next) {
 				XMoveResizeWindow(dpy, m->barwin, m->wx, m->by, m->ww, bh);
+				XMoveResizeWindow(dpy, m->bbarwin, m->wx, m->bby, m->ww, bh);
+			}
 			focus(NULL);
 			arrange(NULL);
 		}
@@ -657,6 +668,8 @@
 	m->nmaster = nmaster;
 	m->showbar = showbar;
 	m->topbar = topbar;
+	m->bottombar = bottombar;
+	m->showbottombar = bottombar ? True : False;
 	m->lt[0] = &layouts[0];
 	m->lt[1] = &layouts[1 % LENGTH(layouts)];
 	strncpy(m->ltsymbol, layouts[0].symbol, sizeof m->ltsymbol);
@@ -755,6 +768,15 @@
 			drawtext(NULL, dc.norm, False);
 	}
 	XCopyArea(dpy, dc.drawable, m->barwin, dc.gc, 0, 0, m->ww, bh, 0, 0);
+	if(m->showbottombar) {
+		dc.x = 0;
+		dc.w = TEXTW(btext);
+		drawtext(btext, dc.norm, False);
+		dc.x += dc.w;
+		dc.w = m->ww - dc.x;
+		drawtext(NULL, dc.norm, False);
+		XCopyArea(dpy, dc.drawable, m->bbarwin, dc.gc, 0, 0, m->ww, bh, 0, 0);
+	}
 	XSync(dpy, False);
 }
 
@@ -1023,6 +1045,34 @@
 }
 
 void
+grid(Monitor *m) {
+	unsigned int i, n, cx, cy, cw, ch, aw, ah, cols, rows;
+	Client *c;
+
+	for(n = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next))
+		n++;
+
+	/* grid dimensions */
+	for(rows = 0; rows <= n/2; rows++)
+		if(rows*rows >= n)
+			break;
+	cols = (rows && (rows - 1) * rows >= n) ? rows - 1 : rows;
+
+	/* window geoms (cell height/width) */
+	ch = m->wh / (rows ? rows : 1);
+	cw = m->ww / (cols ? cols : 1);
+	for(i = 0, c = nexttiled(m->clients); c; c = nexttiled(c->next)) {
+		cx = m->wx + (i / rows) * cw;
+		cy = m->wy + (i % rows) * ch;
+		/* adjust height/width of last row/column's windows */
+		ah = ((i + 1) % rows == 0) ? m->wh - ch * rows : 0;
+		aw = (i >= rows * (cols - 1)) ? m->ww - cw * cols : 0;
+		resize(c, cx, cy, cw - 2 * c->bw + aw, ch - 2 * c->bw + ah, False);
+		i++;
+	}
+}
+
+void
 incnmaster(const Arg *arg) {
 	selmon->nmaster = MAX(selmon->nmaster + arg->i, 0);
 	arrange(selmon);
@@ -1122,9 +1172,16 @@
 		applyrules(c);
 	}
 	/* geometry */
-	c->x = c->oldx = wa->x;
-	c->y = c->oldy = wa->y;
-	c->w = c->oldw = wa->width;
+	if((!c->mon->lt[c->mon->sellt]->arrange || c->isfloating)) {
+            c->x = c->oldx = c->mon->wx + (c->mon->ww / 2 - wa->width / 2);
+            c->y = c->oldy = c->mon->wy + (c->mon->wh / 2 - wa->height / 2);
+        }
+        else {
+            c->x = c->oldx = wa->x;
+            c->y = c->oldy = wa->y;
+        }
+
+        c->w = c->oldw = wa->width;
 	c->h = c->oldh = wa->height;
 	c->oldbw = wa->border_width;
 
@@ -1745,6 +1802,14 @@
 }
 
 void
+togglebottombar(const Arg *arg) {
+    selmon->showbottombar = !selmon->showbottombar;
+    updatebarpos(selmon);
+    XMoveResizeWindow(dpy, selmon->bbarwin, selmon->wx, selmon->bby, selmon->ww, bh);
+    arrange(selmon);
+}
+
+void
 togglefloating(const Arg *arg) {
 	if(!selmon->sel)
 		return;
@@ -1848,6 +1913,13 @@
 		                          CWOverrideRedirect|CWBackPixmap|CWEventMask, &wa);
 		XDefineCursor(dpy, m->barwin, cursor[CurNormal]);
 		XMapRaised(dpy, m->barwin);
+		if (m->bottombar) {
+			m->bbarwin = XCreateWindow(dpy, root, m->wx, m->bby, m->ww, bh, 0, DefaultDepth(dpy, screen),
+						   CopyFromParent, DefaultVisual(dpy, screen),
+						   CWOverrideRedirect|CWBackPixmap|CWEventMask, &wa);
+			XDefineCursor(dpy, m->bbarwin, cursor[CurNormal]);
+			XMapRaised(dpy, m->bbarwin);
+		}
 	}
 }
 
@@ -1862,6 +1934,12 @@
 	}
 	else
 		m->by = -bh;
+	if (m->showbottombar) {
+		m->wh -= bh;
+		m->bby = m->wy + m->wh;
+	}
+	else
+		m->bby = -bh;
 }
 
 void
@@ -2034,8 +2112,39 @@
 
 void
 updatestatus(void) {
-	if(!gettextprop(root, XA_WM_NAME, stext, sizeof(stext)))
+	char buftext[512];
+	if(!gettextprop(root, XA_WM_NAME, buftext, sizeof(buftext)))
 		strcpy(stext, "dwm-"VERSION);
+	else {
+		char* blocation = strstr(buftext,"BOTTOM=");
+		if (blocation != NULL) {
+			int c = 0;
+			for (char* i = buftext; i < blocation; i++) {
+				if (c < sizeof(stext) - 1)
+					stext[c] = *i;
+				else
+					break;
+				c++;
+			}
+			stext[c] = '\0';
+			blocation += 7;
+			c = 0;
+			for (char* i = blocation; i < (blocation + sizeof(buftext)); i++)
+			{
+				if (c < sizeof(btext) - 1)
+					btext[c] = *i;
+				else
+					break;
+				c++;
+			}
+			btext[c] = '\0';
+		}
+		else {
+			for (int i = 0; i < sizeof(stext); i++)
+			stext[i] = buftext[i];
+			stext[sizeof(stext) - 1] = '\0';
+		}
+	}
 	drawbar(selmon);
 }
 
